/*using Backgammon.Models;
using System.CodeDom;

namespace Backgammon.Util
{
    public static class BoardToNeuralInputsEncoder
    {
        private static readonly float inputMin = -1;
        private static readonly float inputMax = 1;

        public static int MapBoardToModel(int[] board)
        {
            if (BackgammonBoard.StillContact(board))
                return 1;
            return 0;
        }


        public static float[] EncodeBoardToNeuralInputs(int[] points, int modelIndex, int player = BackgammonBoard.Player1, bool alwaysMirror = false)
        {
            if (alwaysMirror || (Constants.MirrorBoardForPlayer2 && player == BackgammonBoard.Player2))
            {
                points = BackgammonBoard.MirrorBoard(points);
            }

            //Would be safer to to use NeuralNetworkManager.MapBoard(int[] board) but hardcoded for little performance
            if (modelIndex == 0)
            {
                return EncodeNoContactBoardToNeuralInputs(points);
            }
            return EncodeContactGameToNeuralInputs(points);
        }

        private static float[] EncodeContactGameToNeuralInputs(int[] points)
        {
            (int p1PipCount, int p2PipCount) = BackgammonBoard.PipCountStatic(points);
            //float[] points1To24 = EncodeBoard1To24ToNeuralInputsSparse(points);// 24Inputs:0-23
            float[] points1To24 = EncodeBoard1To24SemiSparseToNeuralInputs(points);// 24Inputs:0-23
            //var (barCheckers, barLabels) = EncodeBarCheckersToNeuralInputsSparse(points);// 2Inputs:24-25
            var barCheckers = EncodeBarCheckersToNeuralInputs(points);// 12Inputs:
            //We should have 2 inputs for born off also
            float[] borneOffDifference = EncodeBorneOffDifferenceToNeuralInputsSparse(points); // 1 Input 26
            float[] borneOff = EncodeBorneOffNeuralInputsSparse(points); // 2 Inputss 27-28
            float[] pipCountPerc = EncodePipCountPercentageNeuralInputs(p1PipCount, p2PipCount);// 1 input 29
            float[] pipCountDiffShort = EncodePipCountDifferenceToNeuralInputsSparse(p1PipCount - p2PipCount, 15);// 1 Input 31
            float[] pipCountDiffMedium = EncodePipCountDifferenceToNeuralInputsSparse(p1PipCount - p2PipCount, 50);// 1 Input 32
            float[] pipCountDiffLong = EncodePipCountDifferenceToNeuralInputsSparse(p1PipCount - p2PipCount, 150);// 1 Input 33
            //float[] p1PipCountBuckets = PipCountToOverlappingBuckets(p1PipCount);//13 Inputs
            //float[] p2PipCountBuckets = PipCountToOverlappingBuckets(p2PipCount);//13 Inputs
            float[] safePoints = EncodeSafePointsToNeuralInputSparse(points);//2 Inputs 34-35
            float[] prime = EncodePrimesToNeuralInput(points);//6 Inputs 36-41
            float[] blots = EncodeBlotsToNeuralInputSparse(points);//2 Inputs 44-45
            float[] gammonSavePipCount = EncodeGammonSavePipCount(points); // 2 inputs 54-55
            float[] backgammonSavePipCount = EncodeBackGammonSavePipCount(points); // 2 inputs 56-57
            float[] gammonCrossovers = EncodeGammonSaveCrossoverCountSparse(points); // 2 inputs 58-59
            float[] innerBoardStrength = EncodeInnerBoardStrength(points);
            //float[] contact = EncodeStillContact(points); // 1 input Since we have different networks
            float[] directHits = EncodeDirectHits(points);
            float[] gammonSave = EncodeGammonSavedNeuralInputs(points);
            //
            // Combine all the feature vectors into a single array
            var combinedFeatures =
                new List<float>(points1To24.Length + barCheckers.Length + borneOffDifference.Length + borneOff.Length
                + pipCountPerc.Length + pipCountDiffShort.Length + pipCountDiffMedium.Length + pipCountDiffLong.Length
                + safePoints.Length +
                prime.Length + 
                blots.Length + gammonSavePipCount.Length + backgammonSavePipCount.Length
                + gammonCrossovers.Length + innerBoardStrength.Length + directHits.Length + gammonSave.Length);

            combinedFeatures.AddRange(points1To24);
            combinedFeatures.AddRange(barCheckers);
            combinedFeatures.AddRange(borneOffDifference);
            combinedFeatures.AddRange(borneOff);
            combinedFeatures.AddRange(pipCountPerc);
            combinedFeatures.AddRange(pipCountDiffShort);
            combinedFeatures.AddRange(pipCountDiffMedium);
            combinedFeatures.AddRange(pipCountDiffLong);
            //combinedFeatures.AddRange(p1PipCountBuckets);
            //combinedFeatures.AddRange(p2PipCountBuckets);
            combinedFeatures.AddRange(safePoints);
            combinedFeatures.AddRange(prime);
            combinedFeatures.AddRange(blots);
            combinedFeatures.AddRange(gammonSavePipCount);
            combinedFeatures.AddRange(backgammonSavePipCount);
            combinedFeatures.AddRange(gammonCrossovers);
            //combinedFeatures.AddRange(contact);
            combinedFeatures.AddRange(innerBoardStrength);
            combinedFeatures.AddRange(directHits);
            //Console.WriteLine("board" + string.Join(",", points));

            //Console.WriteLine("1 to 24"+ string.Join(",", points1To24));

            // Represent Player1's turn with 1.0f and Player2's turn with -1.0f
            // Skip because mirror board instead
            //float playerTurn = player == BackgammonBoard.Player1 ? 1.0f : -1.0f;
            //combinedFeatures.Add(playerTurn);
            return combinedFeatures.ToArray();
        }

        private static float[] EncodeNoContactBoardToNeuralInputs(int[] points)
        {
            (int p1PipCount, int p2PipCount) = BackgammonBoard.PipCountStatic(points);
            //float[] points1To24 = EncodeBoard1To24ToNeuralInputsSparse(points);// 24Inputs:0-23
            //We should have 2 inputs for born off also
            float[] pipCountPerc = EncodePipCountPercentageNeuralInputs(p1PipCount, p2PipCount);// 1 input 0
            float[] borneOffDifference = EncodeBorneOffDifferenceToNeuralInputsSparse(points); // 1 Input 1
            float[] borneOff = EncodeBorneOffNeuralInputsSparse(points); // 2 Inputss 2, 3  // Val 20 needs scaling ?
            float[] pipCountDiffShort = EncodePipCountDifferenceToNeuralInputsSparse(p1PipCount - p2PipCount, 15);// 1 Input 4
            float[] pipCountDiffMedium = EncodePipCountDifferenceToNeuralInputsSparse(p1PipCount - p2PipCount, 50);// 1 Input 32
            float[] pipCountDiffLong = EncodePipCountDifferenceToNeuralInputsSparse(p1PipCount - p2PipCount, 150);// 1 Input 33
            float[] gammonSavePipCount = EncodeGammonSavePipCount(points); // 2 inputs 54-55
            float[] backgammonSavePipCount = EncodeBackGammonSavePipCount(points); // 2 inputs 56-57
            float[] gammonCrossovers = EncodeGammonSaveCrossoverCountSparse(points); // 2 inputs 58-59
            // Combine all the feature vectors into a single array
            var combinedFeatures =
                new List<float>(borneOffDifference.Length + borneOff.Length
                + pipCountPerc.Length + pipCountDiffShort.Length + pipCountDiffMedium.Length + pipCountDiffLong.Length
                + gammonSavePipCount.Length + backgammonSavePipCount.Length
                + gammonCrossovers.Length);

            //combinedFeatures.AddRange(points1To24);
            combinedFeatures.AddRange(borneOffDifference);
            combinedFeatures.AddRange(borneOff);
            combinedFeatures.AddRange(pipCountPerc);
            combinedFeatures.AddRange(pipCountDiffShort);
            combinedFeatures.AddRange(pipCountDiffMedium);
            combinedFeatures.AddRange(pipCountDiffLong);
            combinedFeatures.AddRange(gammonSavePipCount);
            combinedFeatures.AddRange(backgammonSavePipCount);
            combinedFeatures.AddRange(gammonCrossovers);

            //combinedFeatures.AddRange(directHits);
            //Console.WriteLine("board" + string.Join(",", points));

            //Console.WriteLine("1 to 24"+ string.Join(",", points1To24));

            // Represent Player1's turn with 1.0f and Player2's turn with -1.0f
            //float playerTurn = player == BackgammonBoard.Player1 ? 1.0f : -1.0f;
            //combinedFeatures.Add(playerTurn);
            return combinedFeatures.ToArray();
        }

        private static float CutValue(float val, float min, float max)
        {
            if (val < min)
                return min;
            if (val < max)
                return max;
            return val;
        }

        private static float ScaleToRange(float inputVal, float inputMinVal, float inputMaxVal, float targetMinVal, float targetMaxVal)
        {
            // Ensure input is within bounds
            inputVal = Math.Max(inputMinVal, Math.Min(inputVal, inputMaxVal));

            // Calculate the proportion of input relative to its range
            float proportion = (inputVal - inputMinVal) / (inputMaxVal - inputMinVal);

            // Scale the proportion to the target range
            return targetMinVal + (proportion * (targetMaxVal - targetMinVal));
        }

        private static float ScaleToRangeMinus1Plus1(float inputVal, float inputMinVal, float inputMaxVal)
        {
            // Ensure input is within bounds
            inputVal = Math.Max(inputMinVal, Math.Min(inputVal, inputMaxVal));

            // Calculate the proportion of input relative to its range
            float proportion = (inputVal - inputMinVal) / (inputMaxVal - inputMinVal); //0-1

            float scaled = 2 * proportion - 1;
            // Scale the proportion to the target range
            return scaled;
        }

        private static float ScaleCheckersToInput(int checkers, int maxCheckersConsidered, bool isPlayerOne)
        {
            // Normalize the checker count to be between 0 and 1, capped at MaxCheckersConsidered
            float normalizedCheckers = Math.Min(checkers, maxCheckersConsidered) / (float)maxCheckersConsidered;
            // Scale to [-1, 1] range
            float scaledCheckers = normalizedCheckers * 2 - 1;
            // Invert for player two if needed
            return isPlayerOne ? scaledCheckers : -scaledCheckers;
        }

        private static float[] EncodeBoard1To24ToNeuralInputsSparse(int[] points)
        {
            const int MaxCheckersConsidered = 7;

            const int NumPoints = 24; // 24 Boardpoints to scan
            float[] neuralInputs = new float[NumPoints]; // 24 inputs representing the board state
            //string[] labels = new string[NumPoints];
            for (int i = 0; i < NumPoints; i++)
            {
                if (points[i + 1] > 0)
                {   // Shuld maybe replace with new scaling function
                    // Player 1's checkers
                    neuralInputs[i] = ScaleCheckersToInput(points[i + 1], MaxCheckersConsidered, true);
                }
                else if (points[i + 1] < 0)
                {
                    // Player 2's checkers, invert the sign of points since they are negative
                    neuralInputs[i] = ScaleCheckersToInput(-points[i + 1], MaxCheckersConsidered, false);
                }
                else
                {
                    // No checkers on this point
                    neuralInputs[i] = 0;
                }
                //labels[i] = "input:" + (i + 1);
            }

            return neuralInputs;
        }
        
        private static (float[], string[]) EncodeBarCheckersToNeuralInputsSparse(int[] board)
        {
            const int MaxCheckersConsidered = 6;
            float[] neuralInputs =
            [
                ScaleCheckersToInput(board[BackgammonBoard.OnTheBarP1], MaxCheckersConsidered, true),
                ScaleCheckersToInput(board[BackgammonBoard.OnTheBarP2], MaxCheckersConsidered, false),
            ]; // for two players
            string[] labels = ["OnTheBarP1", "OnTheBarP2"];
            return (neuralInputs, labels);
        }

        private static float ScaleDifferenceToInput(int difference, int maxAbsoluteDifference)
        {
            // Ensure the difference does not exceed the maximum absolute difference
            difference = Math.Clamp(difference, -maxAbsoluteDifference, maxAbsoluteDifference);

            // Normalize the difference to be between -1 and 1
            float normalizedDifference = difference / (float)maxAbsoluteDifference;

            return normalizedDifference;
        }

        public static float[] EncodeBorneOffDifferenceToNeuralInputsSparse(int[] board)
        {
            const int MaxDifference = 15; // Maximum difference to represent, if we don't train on final position 14 could be the limit
            float[] neuralInputs = new float[1];

            // Retrieve the number of borne-off checkers for each player
            int p1BorneOff = Math.Max(board[BackgammonBoard.CheckersOffP1], 0);
            // For Player 2, assuming positive values in CheckersOffP2 represent the count of borne-off checkers correctly
            int p2BorneOff = Math.Max(-board[BackgammonBoard.CheckersOffP2], 0); // Correction for negative representation

            int difference = p1BorneOff - p2BorneOff;

            //neuralInputs[0] = ScaleDifferenceToInput(difference,MaxDifference);
            neuralInputs[0] = ScaleToRangeMinus1Plus1(difference, -MaxDifference, MaxDifference);

            return neuralInputs;
        }

        public static float[] EncodeBorneOffNeuralInputsSparse(int[] board)
        {
            // Retrieve the number of borne-off checkers for each player
            int p1BorneOff = Math.Max(board[BackgammonBoard.CheckersOffP1], 0);
            // For Player 2, assuming positive values in CheckersOffP2 represent the count of borne-off checkers correctly
            int p2BorneOff = Math.Max(-board[BackgammonBoard.CheckersOffP2], 0); // Correction for negative representation
            var p1BorneOffScaled = ScaleToRangeMinus1Plus1(p1BorneOff, 0f, 15f);
            var p2BorneOffScaled = ScaleToRangeMinus1Plus1(p2BorneOff, 0f, 15f);
            return [p1BorneOffScaled, p2BorneOffScaled];
        }

        public static float[] EncodePipCountDifferenceToNeuralInputsSparse(int pipCountDifference, int maxDifference = 40)
        {
            // Initialize neural inputs: 40 for being ahead, 40 for being behind
            float[] neuralInputs = [
                ScaleDifferenceToInput(pipCountDifference, maxDifference),
            ];
            return neuralInputs;
        }

        //Should maybe be only one input, especially if we mirror board
        public static float[] EncodePipCountPercentageNeuralInputs(int pipCountP1, int pipCountP2)
        {
            // At first though one PipCount could be enough but if we code it as percentage lead
            // 
            var maxPercentageCut = 0.3f;
            // How to best deal with pipCountP1 = 0 ? 
            float percentageP1;
            if (pipCountP1 == 0)
            { // the game has ended
                percentageP1 = inputMax; //We treat this as maxim perc lead
            }
            else
            {
                percentageP1 = (pipCountP2 - pipCountP1) / (float)pipCountP1;
                percentageP1 = CutValue(percentageP1, -maxPercentageCut, maxPercentageCut);
            }
            
            
            float percentageP2;
            if (pipCountP2 == 0)
            {
                percentageP2 = inputMax;
            }
            else
            {
                percentageP2 = (pipCountP1 - pipCountP2) / (float)pipCountP2;
                percentageP2 = CutValue(percentageP2, -maxPercentageCut, maxPercentageCut);
            }
            // A missed to scale percP2 but seems network learns better from that one ???
            percentageP1 = ScaleToRange(percentageP1, -maxPercentageCut, maxPercentageCut, -1f, 1f);
            //percentageP2 = ScaleToRange(percentageP2, -maxPercentageCut, maxPercentageCut, -1f, 1f);
            // Initialize neural inputs: 40 for being ahead, 40 for being behind
            
            return [percentageP1];
        }

        
        public static float[] PipCountToOverlappingBuckets(int pipCount, int bucketSize = 20, int maxValue = 260)
        {

            int numBuckets = (maxValue + bucketSize - 1) / bucketSize; //13.95 --> 13
            float[] buckets = new float[numBuckets];

            for (int i = 0; i < numBuckets; i++)
            {
                if (pipCount > i * bucketSize)
                {
                    buckets[i] = 1;
                }
            }

            return buckets;
        }

        private static int CountInnerBoardPoints(int[] board, int player)
        {
            int safeCount = 0;
            // Explicitly loop from index 1 to 24, corresponding to backgammon points 1 through 24.
            for (int point = 1; point <= 6; point++) // Adjusting loop to use 1-based indexing for clarity.
            {
                // Direct comparison without adjusting point, as we're already within the correct range.
                if ((player == BackgammonBoard.Player1 && board[point] >= 2) ||
                    (player == BackgammonBoard.Player2 && board[point + 18] <= -2)) //19-24 for P2
                {
                    safeCount++;
                }
            }
            return safeCount;
        }

        private static float[] EncodeInnerBoardStrengthSparse(int[] board)
        {
            var innerBoardStrengthP1 = CountInnerBoardPoints(board, BackgammonBoard.Player1);
            var innerBoardStrengthP2 = CountInnerBoardPoints(board, BackgammonBoard.Player2);
            var scaledP1 = ScaleToRangeMinus1Plus1(innerBoardStrengthP1, 0f, 6f);
            var scaledP2 = ScaleToRangeMinus1Plus1(innerBoardStrengthP2, 0f, 6f);
            return [scaledP1, scaledP2];
        }

        private static float[] EncodeInnerBoardStrength(int[] board)
        {
            var MaxInnerBoardStrength = 6;
            
            float[] neuralInputs = new float[MaxInnerBoardStrength * 2]; // x2 for two players
            // Initialize all inputs to inputMin
            for (int i = 0; i < neuralInputs.Length; i++)
            {
                neuralInputs[i] = inputMin;
            }

            var innerBoardStrengthP1 = CountInnerBoardPoints(board, BackgammonBoard.Player1);
                        
            for (int i = 0; i < Math.Min(innerBoardStrengthP1, MaxInnerBoardStrength); i++)
            {
                neuralInputs[i] = inputMax;
            }
            
            var innerBoardStrengthP2 = CountInnerBoardPoints(board, BackgammonBoard.Player2);

            for (int i = 0; i < Math.Min(innerBoardStrengthP2, MaxInnerBoardStrength); i++)
            {
                neuralInputs[MaxInnerBoardStrength + i] = inputMax;
            }

            return neuralInputs;
        }


        internal static int CountSafePoints(int[] board, int player)
        {
            int safeCount = 0;
            // Explicitly loop from index 1 to 24, corresponding to backgammon points 1 through 24.
            for (int point = 1; point <= 24; point++) // Adjusting loop to use 1-based indexing for clarity.
            {
                // Direct comparison without adjusting point, as we're already within the correct range.
                if ((player == BackgammonBoard.Player1 && board[point] >= 2) ||
                    (player == BackgammonBoard.Player2 && board[point] <= -2))
                {
                    safeCount++;
                }
            }

            return safeCount;
        }

        public static float[] EncodeSafePointsToNeuralInputSparse(int[] board)
        {
            const int MaxSafePoints = 7;
            int safePointsP1 = CountSafePoints(board, BackgammonBoard.Player1);
            int safePointsP2 = CountSafePoints(board, BackgammonBoard.Player2);
            float[] neuralInputs =
            [
                // Scale the number of safe points to the range [0, 1]
                safePointsP1 / (float)MaxSafePoints,
                safePointsP2 / (float)MaxSafePoints,
            ]; // 1 input for each player

            return neuralInputs;
        }

        internal static int CountPrimes(int[] board, int player)
        {
            int longestPrime = 0;
            int currentPrime = 0;

            // Start iterating from 1 through 24, considering the relevant points for gameplay.
            // Adjust for 0-based indexing in the board array (board[0] is unused in this context).
            for (int i = 1; i <= 24; i++)
            {
                // Check if the point contributes to a prime for the player.
                // Points for Player1 are positive, and points for Player2 are negative.
                if ((player == BackgammonBoard.Player1 && board[i] >= 2) || (player == BackgammonBoard.Player2 && board[i] <= -2))
                {
                    currentPrime += 1;
                }
                else
                {
                    longestPrime = Math.Max(longestPrime, currentPrime);
                    currentPrime = 0; // Reset current prime counter when encountering a non-safe point
                }
            }

            // Account for the last prime potentially ending at the last point.
            longestPrime = Math.Max(longestPrime, currentPrime);

            return longestPrime;
        }

        public static float[] EncodePrimesToNeuralInput(int[] board)
        {
            int longestPrimeP1 = CountPrimes(board, BackgammonBoard.Player1);
            int longestPrimeP2 = CountPrimes(board, BackgammonBoard.Player2);

            // Initialize neural inputs for primes (3 inputs per player)
            float[] neuralInputs = new float[6]; // 3 inputs for each player

            // Encode prime lengths for Player 1
            for (int i = 4; i <= Math.Min(longestPrimeP1, 6); i++)
            {
                neuralInputs[i - 4] = 1; // Marks the presence of 4, 5, and 6-point primes
            }

            // Encode prime lengths for Player 2
            for (int i = 4; i <= Math.Min(longestPrimeP2, 6); i++)
            {
                neuralInputs[3 + i - 4] = 1; // Offset by 3 for Player 2's data
            }

            return neuralInputs;
        }

        private static int CountBlots(int[] board, int player)
        {
            int blotCount = 0;

            // Loop over the relevant points on the backgammon board, excluding "on the bar" positions.
            for (int i = 1; i <= 24; i++)
            {
                if ((player == BackgammonBoard.Player1 && board[i] == 1) || (player == BackgammonBoard.Player2 && board[i] == -1))
                {
                    blotCount++;
                }
            }

            return blotCount;
        }

        public static float[] EncodeBlotsToNeuralInputSparse(int[] board)
        {
            int maxCount = 10;
            int blotsP1 = Math.Min(CountBlots(board, BackgammonBoard.Player1), maxCount);
            int blotsP2 = Math.Min(CountBlots(board, BackgammonBoard.Player2), maxCount);
            // It's very rare to have more than 4-5 blots in practical play but will happen in learning process
            // I will s
            // Initialize neural inputs for blots (5 for each player)
            float[] neuralInputs = [
                blotsP1 /(float)maxCount,
                blotsP2/(float)maxCount,
                ]; // 5 for each player
            return neuralInputs;
        }

        public static float[] EncodeBlotsToNeuralInput(int[] board)
        {
            int blotsP1 = CountBlots(board, BackgammonBoard.Player1);
            int blotsP2 = CountBlots(board, BackgammonBoard.Player2);

            // Initialize neural inputs for blots (5 for each player)
            float[] neuralInputs = new float[10]; // 5 for each player

            // Update inputs based on blots for Player1
            for (int i = 1; i <= Math.Min(blotsP1, 4); i++)
            {
                neuralInputs[i - 1] = 1; // Adjust for zero-based index
            }

            // Update inputs based on blots for Player2
            for (int i = 1; i <= Math.Min(blotsP2, 4); i++)
            {
                neuralInputs[5 + i - 1] = 1; // Adjust for zero-based index and offset for Player 2
            }

            // Set first input to 1 if there are no blots for each player
            neuralInputs[0] = blotsP1 == 0 ? inputMin : inputMax;
            neuralInputs[5] = blotsP2 == 0 ? inputMin : inputMax;

            return neuralInputs;
        }

        public static float NormalizePipCount(int pipCount, int maxPipCount = 50)
        {
            // Ensure the pipCount does not exceed maxPipCount
            int clippedPipCount = Math.Min(pipCount, maxPipCount);

            // Normalize the pipCount to a 0-1 scale
            float normalizedValue = (float)clippedPipCount / maxPipCount;

            return normalizedValue;
        }

        public static float[] EncodeGammonSavePipCount(int[] board)
        {
            int gammonPipsPlayer1 = 0;
            int gammonPipsPlayer2 = 0;
            bool gammonSavedPlayer1, gammonSavedPlayer2;

            // Assuming BackgammonBoard.SavedGammonForBoth() is defined to check if gammon is already saved.
            (gammonSavedPlayer1, gammonSavedPlayer2) = BackgammonBoard.SavedGammonForBoth(board);

            // Calculate pip counts for moving checkers to the home board or beyond.
            if (!gammonSavedPlayer1)
            {
                for (int i = 25; i >= 7; i--)
                {
                    if (board[i] > 0) // Player 1's checkers
                    {
                        int distanceToHome = i - 6; // Adjusting to calculate distance from home board
                        gammonPipsPlayer1 += distanceToHome * board[i];
                    }
                }
            }

            if (!gammonSavedPlayer2)
            {
                for (int i = 0; i <= 18; i++)
                {
                    if (board[i] < 0) // Player 2's checkers
                    {
                        int distanceToHome = 19 - i; // Adjusting for Player 2's checkers towards their home board
                        gammonPipsPlayer2 += distanceToHome * Math.Abs(board[i]);
                    }
                }
            }

            // Normalize the pip counts.
            int maxPipCount = 30; // Adjust the maximum pip count as needed.
            float input1 = NormalizePipCount(gammonPipsPlayer1, maxPipCount);
            float input2 = NormalizePipCount(gammonPipsPlayer2, maxPipCount);

            // Fix for the return statement to use correct C# syntax.
            return [input1, input2];
        }

        public static float[] EncodeBackGammonSavePipCount(int[] board)
        {
            // Assuming methods for checking if gammon is saved and normalization are defined elsewhere.
            bool gammonSavedPlayer1, gammonSavedPlayer2;
            (gammonSavedPlayer1, gammonSavedPlayer2) = BackgammonBoard.SavedGammonForBoth(board);

            int backGammonPipsPlayer1 = 0;
            int backGammonPipsPlayer2 = 0;

            // Calculate pips needed for Player 1's checkers to leave opponent's home board
            if (!gammonSavedPlayer1)
            {
                for (int i = 25; i >= 19; i--) // From the bar (25) to point 19
                {
                    if (board[i] > 0) // Player 1's checkers
                    {
                        // Pips needed from current position to just outside the home board (point 18)
                        int distance = i - 18;
                        backGammonPipsPlayer1 += distance * board[i];
                    }
                }
            }

            // Calculate pips needed for Player 2's checkers to leave opponent's home board
            if (!gammonSavedPlayer2)
            {
                for (int i = 0; i <= 6; i++) // Including the bar (0) up to point 6
                {
                    if (board[i] < 0) // Player 2's checkers
                    {
                        // For Player 2, calculate distance as if moving towards point 19 from their perspective
                        int distance = 7 - i; // Distance to exit the home area (towards point 19)
                        backGammonPipsPlayer2 += distance * Math.Abs(board[i]);
                    }
                }
            }

            int maxPipCount = 30; // Example max pip count for normalization
            float input1 = NormalizePipCount(backGammonPipsPlayer1, maxPipCount);
            float input2 = NormalizePipCount(backGammonPipsPlayer2, maxPipCount);

            return [input1, input2];
        }

        private static float[] EncodeCountAdditive(int count, int maxCount)
        {
            float[] encoded = new float[maxCount];
            for (int i = 0; i < maxCount; i++)
            {
                encoded[i] = i < count ? inputMax : inputMin;
            }
            return encoded;
        }

        // Even though i created this for help with evaluating gammon risk it could also be useful for
        // evaluating how aggressively to play in a bearoff when like after coup classic but then i should 
        // skip checking BackgammonBoard.SavedGammonForBoth(board);
        public static float[] EncodeGammonSaveCrossoverCountSparse(int[] board)
        {
            int gammonCrossoversPlayer1 = 0;
            int gammonCrossoversPlayer2 = 0;
            //bool gammonSavedPlayer1, gammonSavedPlayer2;

            // Assuming BackgammonBoard.SavedGammonForBoth() method exists
            //(gammonSavedPlayer1, gammonSavedPlayer2) = BackgammonBoard.SavedGammonForBoth(board);

            //if (!gammonSavedPlayer2)
            {
                for (int i = 0; i < 19; i++)
                {
                    int checkersAtI = Math.Abs(board[i]);
                    if (board[i] < 0) // Player 2's checkers
                    {
                        if (i == 0)
                            gammonCrossoversPlayer2 += 4 * checkersAtI;
                        else if (i <= 7)
                            gammonCrossoversPlayer2 += 3 * checkersAtI;
                        else if (i <= 13)
                            gammonCrossoversPlayer2 += 2 * checkersAtI;
                        else
                            gammonCrossoversPlayer2 += checkersAtI;
                    }
                }
            }

            //if (!gammonSavedPlayer1)
            {
                for (int i = 0; i < 19; i++)
                {
                    int index = BackgammonBoard.OnTheBarP1 - i;
                    if (board[index] > 0) // Player 1's checkers
                    {
                        int checkersAtI = board[index];
                        if (i == 0)
                            gammonCrossoversPlayer2 += 4 * checkersAtI;
                        else if (i <= 7)
                            gammonCrossoversPlayer1 += 3 * checkersAtI;
                        else if (i <= 13)
                            gammonCrossoversPlayer1 += 2 * checkersAtI;
                        else
                            gammonCrossoversPlayer1 += checkersAtI;
                    }
                }
            }

            int maxCount = 10;
            gammonCrossoversPlayer1 = Math.Min(gammonCrossoversPlayer1, maxCount);
            gammonCrossoversPlayer2 = Math.Min(gammonCrossoversPlayer2, maxCount);
            return [
                    gammonCrossoversPlayer1 / (float)maxCount,
                    gammonCrossoversPlayer2 / (float)maxCount
                ];
        }

        public static float[] EncodeGammonSaveCrossoverCount(int[] board)
        {
            int gammonCrossoversPlayer1 = 0;
            int gammonCrossoversPlayer2 = 0;
            bool gammonSavedPlayer1, gammonSavedPlayer2;

            // Assuming BackgammonBoard.SavedGammonForBoth() method exists
            (gammonSavedPlayer1, gammonSavedPlayer2) = BackgammonBoard.SavedGammonForBoth(board);

            if (!gammonSavedPlayer2)
            {
                for (int i = 0; i < 19; i++)
                {
                    int checkersAtI = Math.Abs(board[i]);
                    if (board[i] < 0) // Player 2's checkers
                    {
                        if (i <= 7)
                            gammonCrossoversPlayer2 += 3 * checkersAtI;
                        else if (i <= 13)
                            gammonCrossoversPlayer2 += 2 * checkersAtI;
                        else
                            gammonCrossoversPlayer2 += checkersAtI;
                    }
                }
            }

            if (!gammonSavedPlayer1)
            {
                for (int i = 0; i < 19; i++)
                {
                    int index = BackgammonBoard.OnTheBarP1 - i;
                    if (board[index] > 0) // Player 1's checkers
                    {
                        int checkersAtI = board[index];
                        if (i <= 7)
                            gammonCrossoversPlayer1 += 3 * checkersAtI;
                        else if (i <= 13)
                            gammonCrossoversPlayer1 += 2 * checkersAtI;
                        else
                            gammonCrossoversPlayer1 += checkersAtI;
                    }
                }
            }

            int maxCount = 5;
            float[] gammonCrossoversP1Encoded = EncodeCountAdditive(gammonCrossoversPlayer1, maxCount);
            float[] gammonCrossoversP2Encoded = EncodeCountAdditive(gammonCrossoversPlayer2, maxCount);

            // Concatenate the encoded crossover counts for both players
            float[] combinedEncodedCrossovers = new float[maxCount * 2];
            Array.Copy(gammonCrossoversP1Encoded, 0, combinedEncodedCrossovers, 0, maxCount);
            Array.Copy(gammonCrossoversP2Encoded, 0, combinedEncodedCrossovers, maxCount, maxCount);

            return combinedEncodedCrossovers;
        }
        public static float[] EncodeStillContact(int[] board)
        {
            bool contact = BackgammonBoard.StillContact(board);
            return [contact ? 1 : 0];
        }

        public static float[] EncodeDirectHits(int[] board)
        {
            // Perhaps reduce to two inputs but hitting with 6s are better than 1s because of extra combinations
            float[] neuralInputs = new float[12]; //
            for (int i = 0; i < neuralInputs.Length; i++)
            {
                neuralInputs[i] = inputMin;
            }
            
            for (int i = 1; i <= 24; i++) // Check points 1 to 24 for blots
            {
                if (board[i] == -1) // Found Player 2 blot
                {
                    for (int die = 1; die <= 6; die++)
                    {
                        int hitFromPoint = i + die;
                        if (hitFromPoint > BackgammonBoard.OnTheBarP1)
                            break;
                        if (board[hitFromPoint] > 0)
                            neuralInputs[die - 1] = inputMax;
                    }
                }

                if (board[i] == 1) // Found Player 1 blot
                {
                    for (int die = 1; die <= 6; die++)
                    {
                        int hitFromPoint = i - die;
                        if (hitFromPoint < BackgammonBoard.OnTheBarP2)
                            break;
                        if (board[hitFromPoint] < 0)
                            neuralInputs[die + 5] = inputMax; // Adjusted index to match Python's zero-indexing
                    }
                }
            }
            return neuralInputs;
        }

        // Check possible direct hits can be  0..6 (6 if all die are a direct hit) 
        public static int CountDirectHits(int[] board, int player)
        {
            var encodedDirectHits = EncodeDirectHits(board);
            var hits = 0;
            for (int die = 0; die < 6; die++)
            {
                var encodedIndex = (player == BackgammonBoard.Player1) ? die + 6 : die;
                if (encodedDirectHits[encodedIndex] > 0)
                {
                    hits++;
                }
            }
            return hits;
        }

       
        public static float[] EncodeBoardToNeuralInputsOld(int[] points, int player = BackgammonBoard.Player1)
        {
            
            //if (player == BackgammonBoard.Player2)
            //{
            //    points = BackgammonBoard.MirrorBoard(points);
            //}

            (int p1PipCount, int p2PipCount) = BackgammonBoard.PipCountStatic(points);
            float[] points1To24 = EncodeBoard1To24ToNeuralInputs(points);// 0 - 288
            float[] barCheckers = EncodeBarCheckersToNeuralInputs(points);// 12Inputs: 576-589
            float[] borneOffDifference = EncodeBorneOffDifferenceToNeuralInputs(points); // 28 Inputs: 590 - 617 
            float[] pipCountDiff = EncodePipCountDifferenceToNeuralInputs(p1PipCount - p2PipCount);// 80Inputs : 618-697
            float[] p1PipCountBuckets = PipCountToOverlappingBuckets(p1PipCount);//13 Inputs 698-
            float[] p2PipCountBuckets = PipCountToOverlappingBuckets(p2PipCount);//13 Inpuys    - 723
            float[] safePoints = EncodeSafePointsToNeuralInput(points);//8 Inputs 724-729
            float[] prime = EncodePrimesToNeuralInput(points);//6 Inputs
            float[] blots = EncodeBlotsToNeuralInput(points);//10 Inputs
            float[] gammonSavePipCount = EncodeGammonSavePipCount(points); // 2 inputs
            float[] backgammonSavePipCount = EncodeBackGammonSavePipCount(points); // 2 inputs
            float[] gammonCrossovers = EncodeGammonSaveCrossoverCount(points); // 10 inputs
            float[] contact = EncodeStillContact(points); // 1 input
            float[] directHits = EncodeDirectHits(points);
            //
            // Combine all the feature vectors into a single array
            var combinedFeatures = new List<float>(points1To24.Length + barCheckers.Length + borneOffDifference.Length
                + pipCountDiff.Length + p1PipCountBuckets.Length + p2PipCountBuckets.Length + safePoints.Length
                + prime.Length + blots.Length + gammonSavePipCount.Length + backgammonSavePipCount.Length
                + gammonCrossovers.Length + contact.Length + directHits.Length);

            combinedFeatures.AddRange(points1To24);
            combinedFeatures.AddRange(barCheckers);
            combinedFeatures.AddRange(borneOffDifference);
            combinedFeatures.AddRange(pipCountDiff);
            combinedFeatures.AddRange(p1PipCountBuckets);
            combinedFeatures.AddRange(p2PipCountBuckets);
            combinedFeatures.AddRange(safePoints);
            combinedFeatures.AddRange(prime);
            combinedFeatures.AddRange(blots);
            combinedFeatures.AddRange(gammonSavePipCount);
            combinedFeatures.AddRange(backgammonSavePipCount);
            combinedFeatures.AddRange(gammonCrossovers);
            combinedFeatures.AddRange(contact);
            combinedFeatures.AddRange(directHits);
            //Console.WriteLine("board" + string.Join(",", points));

            //Console.WriteLine("1 to 24"+ string.Join(",", points1To24));
            
            // Represent Player1's turn with 1.0f and Player2's turn with -1.0f
            float playerTurn = player == BackgammonBoard.Player1 ? 1.0f : -1.0f;
            combinedFeatures.Add(playerTurn);
            return combinedFeatures.ToArray();
        }

        private static float[] EncodeBoard1To24ToNeuralInputs(int[] points)
        {
            // 24 * 12 -> 288 Input
            const int MaxCheckers = 6;
            const int NumPoints = 24;// 24 Boardpoints to scan
            const int InputsPerPoint = 12;// 6 for each player
            float[] neuralInputs = new float[NumPoints * InputsPerPoint]; // x2 for two players
            for (int i = 0; i < NumPoints; i++)
            {
                // Player 1's checkers
                int p1Checkers = Math.Max(points[i + BackgammonBoard.AcePointP1], 0); // Adjust index for 0-based
                                                                                      //Console.WriteLine($"{i+1} p1 ch {p1Checkers}");
                for (int j = 0; j < Math.Min(p1Checkers, MaxCheckers); j++)
                {
                    // Should we set first input to zero when a point has more than one checker so it represents a blot ?
                    if (p1Checkers > 1 && j == 0)
                    {
                        continue;
                    }
                    int index = i * InputsPerPoint + j;
                    //Console.WriteLine("Setting p1 index" + index);
                    neuralInputs[index] = 1;
                }

                // Player 2's checkers
                int p2Checkers = Math.Max(-points[i + BackgammonBoard.AcePointP1], 0); // Adjust index for 0-based
                                                                                       //Console.WriteLine($"{i+1} p2 ch {p2Checkers}");
                for (int j = 0; j < Math.Min(p2Checkers, MaxCheckers); j++)
                {
                    if (p2Checkers > 1 && j == 0)
                    {
                        continue;
                    }
                    int index = i * InputsPerPoint + j + MaxCheckers;
                    //Console.WriteLine("Setting p2 index" + index);
                    neuralInputs[index] = 1;
                }
            }

            return neuralInputs;
        }

        private static float[] EncodeBoard1To24SemiSparseToNeuralInputs(int[] points)
        {
            var encodedBlots = EncodeBlotsToNeuralInputs(points);
            var encodedSafePoints = EncodeSafePoints1to24ToNeuralInputs(points);
            var encodedSparesPoints = EncodeSparesToNeuralInputs(points);
            var combinedFeatures =
                new List<float>(encodedBlots.Length + encodedSafePoints.Length + encodedSparesPoints.Length);

            combinedFeatures.AddRange(encodedBlots);
            combinedFeatures.AddRange(encodedSafePoints);
            combinedFeatures.AddRange(encodedSparesPoints);
            return [.. combinedFeatures];
        }

        private static float[] EncodeBlotsToNeuralInputs(int[] points)
        {
            // 24 * 2 -> 48 Input
            const int NumPoints = 24;// 24 Boardpoints to scan
            const int InputsPerPoint = 2;//
            float[] neuralInputs = new float[NumPoints * InputsPerPoint]; // x2 for two players
            //string[] labels = new string[NumPoints * InputsPerPoint];
            for (int i = 0; i < NumPoints; i++)
            {
                neuralInputs[i] = points[BackgammonBoard.AcePointP1 + i] == 1 ? inputMin : inputMax;
                //labels[i] = "Blots" + i + "P1";
                neuralInputs[i + NumPoints] = points[BackgammonBoard.AcePointP1 + i] == -1 ? inputMin : inputMax;
                //labels[i + NumPoints] = "Blots" + i + "P2";
            }

            return neuralInputs;
        }

        private static float[] EncodeSafePoints1to24ToNeuralInputs(int[] points)
        {
            // 24 * 2 -> 48 Input
            const int NumPoints = 24; // 24 Boardpoints to scan
            const int InputsPerPoint = 2; //
            float[] neuralInputs = new float[NumPoints * InputsPerPoint]; // x2 for two players
            string[] labels = new string[NumPoints * InputsPerPoint];
            for (int i = 0; i < NumPoints; i++)
            {
                neuralInputs[i] = points[BackgammonBoard.AcePointP1 + i] > 1 ? inputMin : inputMax;
                labels[i] = "Safe" + i + "P1";
                neuralInputs[i + NumPoints] = points[BackgammonBoard.AcePointP1 + i] < -1 ? inputMin : inputMax;
                labels[i + NumPoints] = "Safe" + i + "P2";
            }
            return neuralInputs;
        }

        private static float[] EncodeSparesToNeuralInputs(int[] points)
        {
            // 24 * 2 -> 48 Input
            const int NumPoints = 24;// 24 Boardpoints to scan
            const int InputsPerPoint = 2;//
            const int MaxSpares = 4;
            float[] neuralInputs = new float[NumPoints * InputsPerPoint]; // x2 for two players
            for (int i = 0; i < NumPoints; i++)
            {
                int sparesP1 = Math.Min(Math.Max(points[BackgammonBoard.AcePointP1 + i] - 2, 0), MaxSpares);
                int sparesP2 = Math.Min(Math.Max(-points[BackgammonBoard.AcePointP1 + i] - 2, 0), MaxSpares);
                neuralInputs[i] = ScaleToRangeMinus1Plus1(sparesP1, 0, MaxSpares);
                neuralInputs[i + NumPoints] = ScaleToRangeMinus1Plus1(sparesP2, 0, MaxSpares);
            }
            return neuralInputs;
        }



        private static float[] EncodeBarCheckersToNeuralInputs(int[] board)
        {
            const int MaxCheckers = 6; // Maximum number of checkers to represent on the bar
            float[] neuralInputs = new float[MaxCheckers * 2]; // x2 for two players
            // Initialize all inputs to inputMin
            for (int i = 0; i < neuralInputs.Length; i++)
            {
                neuralInputs[i] = inputMin;
            }


            // Player 1's checkers on the bar
            int p1BarCheckers = Math.Max(board[BackgammonBoard.OnTheBarP1], 0);
            for (int i = 0; i < Math.Min(p1BarCheckers, MaxCheckers); i++)
            {
                neuralInputs[i] = inputMax;
            }

            // Player 2's checkers on the bar, assuming ON_THE_BAR_P2 is appropriately defined in BackgammonBoard
            int p2BarCheckers = Math.Max(-board[BackgammonBoard.OnTheBarP2], 0); // Assuming negative values for Player 2's checkers
            for (int i = 0; i < Math.Min(p2BarCheckers, MaxCheckers); i++)
            {
                neuralInputs[MaxCheckers + i] = inputMax;
            }

            return neuralInputs;
        }


        public static float[] EncodePrimesToNeuralInputSparse(int[] board)
        {
            int longestPrimeP1 = CountPrimes(board, BackgammonBoard.Player1);
            int longestPrimeP2 = CountPrimes(board, BackgammonBoard.Player2);

            float[] neuralInputs =
            [
                // Scale the prime importance for Player 1
                ScalePrimeImportance(longestPrimeP1),
                // Scale the prime importance for Player 2
                ScalePrimeImportance(longestPrimeP2),
            ]; // 1 input for each player

            return neuralInputs;
        }

        private static float ScalePrimeImportance(int primeLength)
        {
            // You might define the scaling function based on the game's strategy.
            // For simplicity, here's an example that emphasizes primes longer than 3.
            if (primeLength < 4) return 0; // Primes shorter than 4 have no importance.
            return (primeLength - 3) / 3.0f; // Scale such that 4->0.33, 5->0.67, 6->1.0
        }


        private static float[] EncodeGammonSavedNeuralInputs(int[] board)
        {
            var (gammonSavedPlayer1, gammonSavedPlayer2) = BackgammonBoard.SavedGammonForBoth(board);
            return [
                 gammonSavedPlayer1 ? inputMin : inputMax,
                 gammonSavedPlayer2 ? inputMin : inputMax,
           ];
        }

        public static float[] EncodeBorneOffDifferenceToNeuralInputs(int[] board)
        {
            const int MaxDifference = 14; // Maximum difference to represent
            float[] neuralInputs = new float[MaxDifference * 2]; // x2 for two players

            // Retrieve the number of borne-off checkers for each player
            int p1BorneOff = Math.Max(board[BackgammonBoard.CheckersOffP1], 0);
            // For Player 2, assuming positive values in CheckersOffP2 represent the count of borne-off checkers correctly
            int p2BorneOff = Math.Max(-board[BackgammonBoard.CheckersOffP2], 0); // Correction for negative representation

            int difference = p1BorneOff - p2BorneOff;

            // Cap the difference at +/-max_difference
            int cappedDifference = Math.Max(Math.Min(difference, MaxDifference), -MaxDifference);

            // Encode the difference
            if (cappedDifference > 0)
            {
                for (int i = 0; i < cappedDifference; i++)
                {
                    neuralInputs[i] = 1; // Positive difference for Player 1
                }
            }
            else if (cappedDifference < 0)
            {
                for (int i = 0; i < -cappedDifference; i++)
                {
                    neuralInputs[MaxDifference + i] = 1; // Negative difference for Player 2
                }
            }

            return neuralInputs;
        }
    }

    public static float[] EncodeSafePointsToNeuralInput(int[] board)
{
int safePointsP1 = CountSafePoints(board, BackgammonBoard.Player1);
int safePointsP2 = CountSafePoints(board, BackgammonBoard.Player2);
// Assuming 4 categories for each player representing 4, 5, 6, 7+ safe points.
float[] neuralInputs = new float[8]; // 4 inputs for each player

// Encode safe points for Player 1
for (int i = 4; i < safePointsP1 && i < 8; i++)
{
neuralInputs[i - 4] = 1; // Adjust for zero-based index and target range
}

// Encode safe points for Player 2
for (int i = 4; i < safePointsP2 && i < 8; i++)
{
neuralInputs[4 + i - 4] = 1; // Adjust for zero-based index, target range, and offset for Player 2
}

return neuralInputs;
}



    public static float[] EncodePipCountDifferenceToNeuralInputs(int pipCountDifference, int maxDifference = 40)
{
// Initialize neural inputs: 40 for being ahead, 40 for being behind
float[] neuralInputs = new float[maxDifference * 2];

int startIndex;
int cappedDifference;

if (pipCountDifference > 0)
{
    // Player is ahead
    startIndex = 0;
    cappedDifference = Math.Min(pipCountDifference, maxDifference);
}
else
{
    // Player is behind
    startIndex = maxDifference;
    cappedDifference = Math.Min(-pipCountDifference, maxDifference);
}

// Encode the pip count difference
for (int i = 0; i < cappedDifference; i++)
{
    neuralInputs[startIndex + i] = 1;
}

return neuralInputs;
}

}*/